# -*- coding: utf-8 -*-
"""Inception_Net

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FO9HHgqXt2VMPYmY0BxWYPtsvcwX97Ph
"""

# Commented out IPython magic to ensure Python compatibility.
## Standard libraries
import os
import numpy as np
from PIL import Image
from typing import Any
from collections import defaultdict
import time

## Imports for plotting
import matplotlib.pyplot as plt
# %matplotlib inline
from IPython.display import set_matplotlib_formats
set_matplotlib_formats('svg', 'pdf') # For export
import matplotlib
matplotlib.rcParams['lines.linewidth'] = 2.0
import seaborn as sns
sns.reset_orig()

## Progress bar
from tqdm.auto import tqdm

## To run JAX on TPU in Google Colab, uncomment the two lines below
# import jax.tools.colab_tpu
# jax.tools.colab_tpu.setup_tpu()

## JAX
import jax
import jax.numpy as jnp
from jax import random
# Seeding for random operations
main_rng = random.PRNGKey(42)

## Flax (NN in JAX)
try:
    import flax
except ModuleNotFoundError: # Install flax if missing
    !pip install --quiet flax
    import flax
from flax import linen as nn
from flax.training import train_state, checkpoints

## Optax (Optimizers in JAX)
try:
    import optax
except ModuleNotFoundError: # Install optax if missing
    !pip install --quiet optax
    import optax

## PyTorch
import torch
import torch.utils.data as data
from torch.utils.tensorboard import SummaryWriter
import torchvision
from torchvision import transforms
from torchvision.datasets import CIFAR10

# Path to the folder where the datasets are/should be downloaded (e.g. CIFAR10)
DATASET_PATH = "/data"
# Path to the folder where the pretrained models are saved
CHECKPOINT_PATH = "/saved_models/CNN"

print("Device:", jax.devices()[0])

import urllib.request
from urllib.error import HTTPError
# Github URL where saved models are stored for this tutorial
base_url = "https://raw.githubusercontent.com/phlippe/saved_models/main/JAX/tutorial5/"
# Files to download
pretrained_files = ["GoogleNet.ckpt", "ResNet.ckpt", "PreActResNet.ckpt", "DenseNet.ckpt",
                    "tensorboards/GoogleNet/events.out.tfevents.googlenet",
                    "tensorboards/ResNet/events.out.tfevents.resnet",
                    "tensorboards/PreActResNet/events.out.tfevents.preactresnet",
                    "tensorboards/DenseNet/events.out.tfevents.densenet"]
# Create checkpoint path if it doesn't exist yet
os.makedirs(CHECKPOINT_PATH, exist_ok=True)

# For each file, check whether it already exists. If not, try downloading it.
for file_name in pretrained_files:
    file_path = os.path.join(CHECKPOINT_PATH, file_name)
    if "/" in file_name:
        os.makedirs(file_path.rsplit("/",1)[0], exist_ok=True)
    if not os.path.isfile(file_path):
        file_url = base_url + file_name
        print(f"Downloading {file_url}...")
        try:
            urllib.request.urlretrieve(file_url, file_path)
        except HTTPError as e:
            print("Something went wrong. Please try to download the file from the GDrive folder, or contact the author with the full output including the following error:\n", e)

"""### Importing training dataset and calculating statistics"""

train_dataset = CIFAR10(root=DATASET_PATH, train=True, download=True)
DATA_MEANS = (train_dataset.data / 255.0).mean(axis=(0,1,2))
DATA_STD = (train_dataset.data / 255.0).std(axis=(0,1,2))
print("Data mean", DATA_MEANS)
print("Data std", DATA_STD)

# Transformations applied on each image => bring them into a numpy array
def image_to_numpy(img):
    img = np.array(img, dtype=np.float32)
    img = (img / 255. - DATA_MEANS) / DATA_STD
    return img

# We need to stack the batch elements
def numpy_collate(batch):
    if isinstance(batch[0], np.ndarray):
        return np.stack(batch)
    elif isinstance(batch[0], (tuple,list)):
        transposed = zip(*batch)
        return [numpy_collate(samples) for samples in transposed]
    else:
        return np.array(batch)


test_transform = image_to_numpy
# For training, we add some augmentation. Networks are too powerful and would overfit.
train_transform = transforms.Compose([transforms.RandomHorizontalFlip(),
                                      transforms.RandomResizedCrop((32,32),scale=(0.8,1.0),ratio=(0.9,1.1)),
                                      image_to_numpy
                                     ])
# Loading the training dataset. We need to split it into a training and validation part
# We need to do a little trick because the validation set should not use the augmentation.
train_dataset = CIFAR10(root=DATASET_PATH, train=True, transform=train_transform, download=True)
val_dataset = CIFAR10(root=DATASET_PATH, train=True, transform=test_transform, download=True)
train_set, _ = torch.utils.data.random_split(train_dataset, [45000, 5000], generator=torch.Generator().manual_seed(42))
_, val_set = torch.utils.data.random_split(val_dataset, [45000, 5000], generator=torch.Generator().manual_seed(42))

# Loading the test set
test_set = CIFAR10(root=DATASET_PATH, train=False, transform=test_transform, download=True)

# We define a set of data loaders that we can use for training and validation
train_loader = data.DataLoader(train_set,
                               batch_size=128,
                               shuffle=True,
                               drop_last=True,
                               collate_fn=numpy_collate,
                               num_workers=8,
                               persistent_workers=True)
val_loader   = data.DataLoader(val_set,
                               batch_size=128,
                               shuffle=False,
                               drop_last=False,
                               collate_fn=numpy_collate,
                               num_workers=4,
                               persistent_workers=True)
test_loader  = data.DataLoader(test_set,
                               batch_size=128,
                               shuffle=False,
                               drop_last=False,
                               collate_fn=numpy_collate,
                               num_workers=4,
                               persistent_workers=True)

"""Verify whether normalization works by checking mean and std of a single batch"""

imgs, _ = next(iter(train_loader))
print("Batch mean", imgs.mean(axis=(0,1,2)))
print("Batch std", imgs.std(axis=(0,1,2)))

"""### Visualizing images"""

NUM_IMAGES = 4
images = [train_dataset[idx][0] for idx in range(NUM_IMAGES)]
orig_images = [Image.fromarray(train_dataset.data[idx]) for idx in range(NUM_IMAGES)]
orig_images = [test_transform(img) for img in orig_images]

imgs = np.stack(images + orig_images, axis=0)
imgs = torch.from_numpy(imgs).permute(0, 3, 1, 2)
img_grid = torchvision.utils.make_grid(imgs, nrow=4, normalize=True, pad_value=0.5)
img_grid = img_grid.permute(1, 2, 0)

plt.figure(figsize=(8,8))
plt.title("Augmentation examples on CIFAR10 (Top: augmented, bottom: original)")
plt.imshow(img_grid)
plt.axis('off')
plt.show()
plt.close()

class TrainState(train_state.TrainState):
    # A simple extension of TrainState to also include batch statistics
    batch_stats: Any

"""In pytorch this could have been done using batchnorm2d"""

class TrainerModule:

    def __init__(self,
                 model_name : str,
                 model_class : nn.Module,
                 model_hparams : dict,
                 optimizer_name : str,
                 optimizer_hparams : dict,
                 exmp_imgs : Any,
                 seed=42):
        """
        Module for summarizing all training functionalities for classification on CIFAR10.

        Inputs:
            model_name - String of the class name, used for logging and saving
            model_class - Class implementing the neural network
            model_hparams - Hyperparameters of the model, used as input to model constructor
            optimizer_name - String of the optimizer name, supporting ['sgd', 'adam', 'adamw']
            optimizer_hparams - Hyperparameters of the optimizer, including learning rate as 'lr'
            exmp_imgs - Example imgs, used as input to initialize the model
            seed - Seed to use in the model initialization
        """
        super().__init__()
        self.model_name = model_name
        self.model_class = model_class
        self.model_hparams = model_hparams
        self.optimizer_name = optimizer_name
        self.optimizer_hparams = optimizer_hparams
        self.seed = seed
        # Create empty model. Note: no parameters yet
        self.model = self.model_class(**self.model_hparams)
        # Prepare logging
        self.log_dir = os.path.join(CHECKPOINT_PATH, self.model_name)
        self.logger = SummaryWriter(log_dir=self.log_dir)
        # Create jitted training and eval functions
        self.create_functions()
        # Initialize model
        self.init_model(exmp_imgs)

    def create_functions(self):
        # Function to calculate the classification loss and accuracy for a model
        def calculate_loss(params, batch_stats, batch, train):
            imgs, labels = batch
            # Run model. During training, we need to update the BatchNorm statistics.
            outs = self.model.apply({'params': params, 'batch_stats': batch_stats},
                                    imgs,
                                    train=train,
                                    mutable=['batch_stats'] if train else False)
            logits, new_model_state = outs if train else (outs, None)
            loss = optax.softmax_cross_entropy_with_integer_labels(logits, labels).mean()
            acc = (logits.argmax(axis=-1) == labels).mean()
            return loss, (acc, new_model_state)
        # Training function
        def train_step(state, batch):
            loss_fn = lambda params: calculate_loss(params, state.batch_stats, batch, train=True)
            # Get loss, gradients for loss, and other outputs of loss function
            ret, grads = jax.value_and_grad(loss_fn, has_aux=True)(state.params)
            loss, acc, new_model_state = ret[0], *ret[1]
            # Update parameters and batch statistics
            state = state.apply_gradients(grads=grads, batch_stats=new_model_state['batch_stats'])
            return state, loss, acc
        # Eval function
        def eval_step(state, batch):
            # Return the accuracy for a single batch
            _, (acc, _) = calculate_loss(state.params, state.batch_stats, batch, train=False)
            return acc
        # jit for efficiency
        self.train_step = jax.jit(train_step)
        self.eval_step = jax.jit(eval_step)

    def init_model(self, exmp_imgs):
        # Initialize model
        init_rng = jax.random.PRNGKey(self.seed)
        variables = self.model.init(init_rng, exmp_imgs, train=True)
        self.init_params, self.init_batch_stats = variables['params'], variables['batch_stats']
        self.state = None

    def init_optimizer(self, num_epochs, num_steps_per_epoch):
        # Initialize learning rate schedule and optimizer
        if self.optimizer_name.lower() == 'adam':
            opt_class = optax.adam
        elif self.optimizer_name.lower() == 'adamw':
            opt_class = optax.adamw
        elif self.optimizer_name.lower() == 'sgd':
            opt_class = optax.sgd
        else:
            assert False, f'Unknown optimizer "{opt_class}"'
        # We decrease the learning rate by a factor of 0.1 after 60% and 85% of the training
        lr_schedule = optax.piecewise_constant_schedule(
            init_value=self.optimizer_hparams.pop('lr'),
            boundaries_and_scales=
                {int(num_steps_per_epoch*num_epochs*0.6): 0.1,
                 int(num_steps_per_epoch*num_epochs*0.85): 0.1}
        )
        # Clip gradients at max value, and evt. apply weight decay
        transf = [optax.clip(1.0)]
        if opt_class == optax.sgd and 'weight_decay' in self.optimizer_hparams:  # wd is integrated in adamw
            transf.append(optax.add_decayed_weights(self.optimizer_hparams.pop('weight_decay')))
        optimizer = optax.chain(
            *transf,
            opt_class(lr_schedule, **self.optimizer_hparams)
        )
        # Initialize training state
        self.state = TrainState.create(apply_fn=self.model.apply,
                                       params=self.init_params if self.state is None else self.state.params,
                                       batch_stats=self.init_batch_stats if self.state is None else self.state.batch_stats,
                                       tx=optimizer)

    def train_model(self, train_loader, val_loader, num_epochs=200):
        # Train model for defined number of epochs
        # We first need to create optimizer and the scheduler for the given number of epochs
        self.init_optimizer(num_epochs, len(train_loader))
        # Track best eval accuracy
        best_eval = 0.0
        for epoch_idx in tqdm(range(1, num_epochs+1)):
            self.train_epoch(train_loader, epoch=epoch_idx)
            if epoch_idx % 2 == 0:
                eval_acc = self.eval_model(val_loader)
                self.logger.add_scalar('val/acc', eval_acc, global_step=epoch_idx)
                if eval_acc >= best_eval:
                    best_eval = eval_acc
                    self.save_model(step=epoch_idx)
                self.logger.flush()

    def train_epoch(self, train_loader, epoch):
        # Train model for one epoch, and log avg loss and accuracy
        metrics = defaultdict(list)
        for batch in tqdm(train_loader, desc='Training', leave=False):
            self.state, loss, acc = self.train_step(self.state, batch)
            metrics['loss'].append(loss)
            metrics['acc'].append(acc)
        for key in metrics:
            avg_val = np.stack(jax.device_get(metrics[key])).mean()
            self.logger.add_scalar('train/'+key, avg_val, global_step=epoch)

    def eval_model(self, data_loader):
        # Test model on all images of a data loader and return avg loss
        correct_class, count = 0, 0
        for batch in data_loader:
            acc = self.eval_step(self.state, batch)
            correct_class += acc * batch[0].shape[0]
            count += batch[0].shape[0]
        eval_acc = (correct_class / count).item()
        return eval_acc

    def save_model(self, step=0):
        # Save current model at certain training iteration
        checkpoints.save_checkpoint(ckpt_dir=self.log_dir,
                                    target={'params': self.state.params,
                                            'batch_stats': self.state.batch_stats},
                                    step=step,
                                   overwrite=True)

    def load_model(self, pretrained=False):
        # Load model. We use different checkpoint for pretrained models
        if not pretrained:
            state_dict = checkpoints.restore_checkpoint(ckpt_dir=self.log_dir, target=None)
        else:
            state_dict = checkpoints.restore_checkpoint(ckpt_dir=os.path.join(CHECKPOINT_PATH, f'{self.model_name}.ckpt'), target=None)
        self.state = TrainState.create(apply_fn=self.model.apply,
                                       params=state_dict['params'],
                                       batch_stats=state_dict['batch_stats'],
                                       tx=self.state.tx if self.state else optax.sgd(0.1)   # Default optimizer
                                      )

    def checkpoint_exists(self):
        # Check whether a pretrained model exist for this autoencoder
        return os.path.isfile(os.path.join(CHECKPOINT_PATH, f'{self.model_name}.ckpt'))

def train_classifier(*args, num_epochs=200, **kwargs):
    # Create a trainer module with specified hyperparameters
    trainer = TrainerModule(*args, **kwargs)
    if not trainer.checkpoint_exists():  # Skip training if pretrained model exists
        trainer.train_model(train_loader, val_loader, num_epochs=num_epochs)
        trainer.load_model()
    else:
        trainer.load_model(pretrained=True)
    # Test trained model
    val_acc = trainer.eval_model(val_loader)
    test_acc = trainer.eval_model(test_loader)
    return trainer, {'val': val_acc, 'test': test_acc}

"""### Defining the convolutional neural networks

### Inception

![image.png](data:image/png;base64,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)

`c_red`: Bottleneck layer - 5*5 convolutions are computationally expensive. So we first do 1*1 to reduce number of channels

Concatenation: We stack the outputs of all four branches that have been calculated in parallel so far
"""

googlenet_kernel_init = nn.initializers.kaiming_normal()

class InceptionBlock(nn.Module):
    c_red : dict  # Dictionary of reduced dimensionalities with keys "1x1", "3x3", "5x5", and "max"
    c_out : dict  # Dictionary of output feature sizes with keys "1x1", "3x3", "5x5", and "max"
    act_fn : callable   # Activation function

    @nn.compact
    def __call__(self, x, train=True):
        # 1x1 convolution branch
        x_1x1 = nn.Conv(self.c_out["1x1"], kernel_size=(1, 1), kernel_init=googlenet_kernel_init, use_bias=False)(x)
        x_1x1 = nn.BatchNorm()(x_1x1, use_running_average=not train)
        x_1x1 = self.act_fn(x_1x1)

        # 3x3 convolution branch
        x_3x3 = nn.Conv(self.c_red["3x3"], kernel_size=(1, 1), kernel_init=googlenet_kernel_init, use_bias=False)(x)
        x_3x3 = nn.BatchNorm()(x_3x3, use_running_average=not train)
        x_3x3 = self.act_fn(x_3x3)
        x_3x3 = nn.Conv(self.c_out["3x3"], kernel_size=(3, 3), kernel_init=googlenet_kernel_init, use_bias=False)(x_3x3)
        x_3x3 = nn.BatchNorm()(x_3x3, use_running_average=not train)
        x_3x3 = self.act_fn(x_3x3)

        # 5x5 convolution branch
        x_5x5 = nn.Conv(self.c_red["5x5"], kernel_size=(1, 1), kernel_init=googlenet_kernel_init, use_bias=False)(x)
        x_5x5 = nn.BatchNorm()(x_5x5, use_running_average=not train)
        x_5x5 = self.act_fn(x_5x5)
        x_5x5 = nn.Conv(self.c_out["5x5"], kernel_size=(5, 5), kernel_init=googlenet_kernel_init, use_bias=False)(x_5x5)
        x_5x5 = nn.BatchNorm()(x_5x5, use_running_average=not train)
        x_5x5 = self.act_fn(x_5x5)

        # Max-pool branch
        x_max = nn.max_pool(x, (3, 3), strides=(2, 2))
        x_max = nn.Conv(self.c_out["max"], kernel_size=(1, 1), kernel_init=googlenet_kernel_init, use_bias=False)(x)
        x_max = nn.BatchNorm()(x_max, use_running_average=not train)
        x_max = self.act_fn(x_max)

        x_out = jnp.concatenate([x_1x1, x_3x3, x_5x5, x_max], axis=-1)
        return x_out

"""`use_running_average = not train` tells the layer to behave differently during training versus evaluation

* Earlier by giving `mutable = ['batch_stats']` we are giving model.apply special permission to change the batch_stats ingredients
"""

class GoogleNet(nn.Module):
    num_classes : int
    act_fn : callable

    @nn.compact
    def __call__(self, x, train=True):
        # A first convolution on the original image to scale up the channel size
        x = nn.Conv(64, kernel_size=(3, 3), kernel_init=googlenet_kernel_init, use_bias=False)(x)
        x = nn.BatchNorm()(x, use_running_average=not train)
        x = self.act_fn(x)

        # Stacking inception blocks
        inception_blocks = [
            InceptionBlock(c_red={"3x3": 32, "5x5": 16}, c_out={"1x1": 16, "3x3": 32, "5x5": 8, "max": 8}, act_fn=self.act_fn),
            InceptionBlock(c_red={"3x3": 32, "5x5": 16}, c_out={"1x1": 24, "3x3": 48, "5x5": 12, "max": 12}, act_fn=self.act_fn),
            lambda inp: nn.max_pool(inp, (3, 3), strides=(2, 2)),  # 32x32 => 16x16
            InceptionBlock(c_red={"3x3": 32, "5x5": 16}, c_out={"1x1": 24, "3x3": 48, "5x5": 12, "max": 12}, act_fn=self.act_fn),
            InceptionBlock(c_red={"3x3": 32, "5x5": 16}, c_out={"1x1": 16, "3x3": 48, "5x5": 16, "max": 16}, act_fn=self.act_fn),
            InceptionBlock(c_red={"3x3": 32, "5x5": 16}, c_out={"1x1": 16, "3x3": 48, "5x5": 16, "max": 16}, act_fn=self.act_fn),
            InceptionBlock(c_red={"3x3": 32, "5x5": 16}, c_out={"1x1": 32, "3x3": 48, "5x5": 24, "max": 24}, act_fn=self.act_fn),
            lambda inp: nn.max_pool(inp, (3, 3), strides=(2, 2)),  # 16x16 => 8x8
            InceptionBlock(c_red={"3x3": 48, "5x5": 16}, c_out={"1x1": 32, "3x3": 64, "5x5": 16, "max": 16}, act_fn=self.act_fn),
            InceptionBlock(c_red={"3x3": 48, "5x5": 16}, c_out={"1x1": 32, "3x3": 64, "5x5": 16, "max": 16}, act_fn=self.act_fn)
        ]
        for block in inception_blocks:
            x = block(x, train=train) if isinstance(block, InceptionBlock) else block(x)

        # Mapping to classification output
        x = x.mean(axis=(1, 2))
        x = nn.Dense(self.num_classes)(x)
        return x

googlenet_trainer, googlenet_results = train_classifier(model_class=GoogleNet,
                                                        model_name="GoogleNet",
                                                        model_hparams={"num_classes": 10,
                                                                       "act_fn": nn.relu},
                                                        optimizer_name="adamw",
                                                        optimizer_hparams={"lr": 1e-3,
                                                                           "weight_decay": 1e-4},
                                                        exmp_imgs=jax.device_put(
                                                            next(iter(train_loader))[0]),
                                                        num_epochs=200)

print("GoogleNet Results", googlenet_results)

