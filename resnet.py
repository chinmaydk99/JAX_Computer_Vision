# -*- coding: utf-8 -*-
"""Resnet

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1abWCoIF5lpqz2qx8lWVvdwDch3yRsf93

## Key Learning

* `model.init()` - Call this once to create initial params and state Pytrees. Requires a PRNGKey and dummy input data to infer all necessary shapes
* `model.apply()` : Call this for every forward pass. We must provide params, state and input data. Executes logic inside `__call__()` method
* nn.Module is a blueprint and not a container. It is stateless and parameters are stored independently
* We must explicitly pass in a boolean flag (train = True) through our model and use it to control behavior of layers like Batchnorm, dropout

## Resnet Specific
* We have a `block_class` argument which helps us build generic containers. In this code we can use it to either use original resnet or pre activation resnet blocks
* Using `subsample` we implement conditional logic for downsampling
"""

# Commented out IPython magic to ensure Python compatibility.
## Standard libraries
import os
import numpy as np
from PIL import Image
from typing import Any
from collections import defaultdict
import time

## Imports for plotting
import matplotlib.pyplot as plt
# %matplotlib inline
from IPython.display import set_matplotlib_formats
set_matplotlib_formats('svg', 'pdf') # For export
import matplotlib
matplotlib.rcParams['lines.linewidth'] = 2.0
import seaborn as sns
sns.reset_orig()

## Progress bar
from tqdm.auto import tqdm

## To run JAX on TPU in Google Colab, uncomment the two lines below
# import jax.tools.colab_tpu
# jax.tools.colab_tpu.setup_tpu()

## JAX
import jax
import jax.numpy as jnp
from jax import random
# Seeding for random operations
main_rng = random.PRNGKey(42)

## Flax (NN in JAX)
try:
    import flax
except ModuleNotFoundError: # Install flax if missing
    !pip install --quiet flax
    import flax
from flax import linen as nn
from flax.training import train_state, checkpoints

## Optax (Optimizers in JAX)
try:
    import optax
except ModuleNotFoundError: # Install optax if missing
    !pip install --quiet optax
    import optax

## PyTorch
import torch
import torch.utils.data as data
from torch.utils.tensorboard import SummaryWriter
import torchvision
from torchvision import transforms
from torchvision.datasets import CIFAR10

# Path to the folder where the datasets are/should be downloaded (e.g. CIFAR10)
DATASET_PATH = "/data"
# Path to the folder where the pretrained models are saved
CHECKPOINT_PATH = "/saved_models/resnet"

print("Device:", jax.devices()[0])

import urllib.request
from urllib.error import HTTPError
# Github URL where saved models are stored for this tutorial
base_url = "https://raw.githubusercontent.com/phlippe/saved_models/main/JAX/tutorial5/"
# Files to download
pretrained_files = ["GoogleNet.ckpt", "ResNet.ckpt", "PreActResNet.ckpt", "DenseNet.ckpt",
                    "tensorboards/GoogleNet/events.out.tfevents.googlenet",
                    "tensorboards/ResNet/events.out.tfevents.resnet",
                    "tensorboards/PreActResNet/events.out.tfevents.preactresnet",
                    "tensorboards/DenseNet/events.out.tfevents.densenet"]
# Create checkpoint path if it doesn't exist yet
os.makedirs(CHECKPOINT_PATH, exist_ok=True)

# For each file, check whether it already exists. If not, try downloading it.
for file_name in pretrained_files:
    file_path = os.path.join(CHECKPOINT_PATH, file_name)
    if "/" in file_name:
        os.makedirs(file_path.rsplit("/",1)[0], exist_ok=True)
    if not os.path.isfile(file_path):
        file_url = base_url + file_name
        print(f"Downloading {file_url}...")
        try:
            urllib.request.urlretrieve(file_url, file_path)
        except HTTPError as e:
            print("Something went wrong. Please try to download the file from the GDrive folder, or contact the author with the full output including the following error:\n", e)

train_dataset = CIFAR10(root=DATASET_PATH, train=True, download=True)
DATA_MEANS = (train_dataset.data / 255.0).mean(axis=(0,1,2))
DATA_STD = (train_dataset.data / 255.0).std(axis=(0,1,2))
print("Data mean", DATA_MEANS)
print("Data std", DATA_STD)

# Transformations applied on each image => bring them into a numpy array
def image_to_numpy(img):
    img = np.array(img, dtype=np.float32)
    img = (img / 255. - DATA_MEANS) / DATA_STD
    return img

# We need to stack the batch elements
def numpy_collate(batch):
    if isinstance(batch[0], np.ndarray):
        return np.stack(batch)
    elif isinstance(batch[0], (tuple,list)):
        transposed = zip(*batch)
        return [numpy_collate(samples) for samples in transposed]
    else:
        return np.array(batch)


test_transform = image_to_numpy
# For training, we add some augmentation. Networks are too powerful and would overfit.
train_transform = transforms.Compose([transforms.RandomHorizontalFlip(),
                                      transforms.RandomResizedCrop((32,32),scale=(0.8,1.0),ratio=(0.9,1.1)),
                                      image_to_numpy
                                     ])
# Loading the training dataset. We need to split it into a training and validation part
# We need to do a little trick because the validation set should not use the augmentation.
train_dataset = CIFAR10(root=DATASET_PATH, train=True, transform=train_transform, download=True)
val_dataset = CIFAR10(root=DATASET_PATH, train=True, transform=test_transform, download=True)
train_set, _ = torch.utils.data.random_split(train_dataset, [45000, 5000], generator=torch.Generator().manual_seed(42))
_, val_set = torch.utils.data.random_split(val_dataset, [45000, 5000], generator=torch.Generator().manual_seed(42))

# Loading the test set
test_set = CIFAR10(root=DATASET_PATH, train=False, transform=test_transform, download=True)

# We define a set of data loaders that we can use for training and validation
train_loader = data.DataLoader(train_set,
                               batch_size=128,
                               shuffle=True,
                               drop_last=True,
                               collate_fn=numpy_collate,
                               num_workers=8,
                               persistent_workers=True)
val_loader   = data.DataLoader(val_set,
                               batch_size=128,
                               shuffle=False,
                               drop_last=False,
                               collate_fn=numpy_collate,
                               num_workers=4,
                               persistent_workers=True)
test_loader  = data.DataLoader(test_set,
                               batch_size=128,
                               shuffle=False,
                               drop_last=False,
                               collate_fn=numpy_collate,
                               num_workers=4,
                               persistent_workers=True)

imgs, _ = next(iter(train_loader))
print("Batch mean", imgs.mean(axis=(0,1,2)))
print("Batch std", imgs.std(axis=(0,1,2)))

NUM_IMAGES = 4
images = [train_dataset[idx][0] for idx in range(NUM_IMAGES)]
orig_images = [Image.fromarray(train_dataset.data[idx]) for idx in range(NUM_IMAGES)]
orig_images = [test_transform(img) for img in orig_images]

imgs = np.stack(images + orig_images, axis=0)
imgs = torch.from_numpy(imgs).permute(0, 3, 1, 2)
img_grid = torchvision.utils.make_grid(imgs, nrow=4, normalize=True, pad_value=0.5)
img_grid = img_grid.permute(1, 2, 0)

plt.figure(figsize=(8,8))
plt.title("Augmentation examples on CIFAR10 (Top: augmented, bottom: original)")
plt.imshow(img_grid)
plt.axis('off')
plt.show()
plt.close()

class TrainState(train_state.TrainState):
    # A simple extension of TrainState to also include batch statistics
    batch_stats: Any

class TrainerModule:

    def __init__(self,
                 model_name : str,
                 model_class : nn.Module,
                 model_hparams : dict,
                 optimizer_name : str,
                 optimizer_hparams : dict,
                 exmp_imgs : Any,
                 seed=42):
        """
        Module for summarizing all training functionalities for classification on CIFAR10.

        Inputs:
            model_name - String of the class name, used for logging and saving
            model_class - Class implementing the neural network
            model_hparams - Hyperparameters of the model, used as input to model constructor
            optimizer_name - String of the optimizer name, supporting ['sgd', 'adam', 'adamw']
            optimizer_hparams - Hyperparameters of the optimizer, including learning rate as 'lr'
            exmp_imgs - Example imgs, used as input to initialize the model
            seed - Seed to use in the model initialization
        """
        super().__init__()
        self.model_name = model_name
        self.model_class = model_class
        self.model_hparams = model_hparams
        self.optimizer_name = optimizer_name
        self.optimizer_hparams = optimizer_hparams
        self.seed = seed
        # Create empty model. Note: no parameters yet
        self.model = self.model_class(**self.model_hparams)
        # Prepare logging
        self.log_dir = os.path.join(CHECKPOINT_PATH, self.model_name)
        self.logger = SummaryWriter(log_dir=self.log_dir)
        # Create jitted training and eval functions
        self.create_functions()
        # Initialize model
        self.init_model(exmp_imgs)

    def create_functions(self):
        # Function to calculate the classification loss and accuracy for a model
        def calculate_loss(params, batch_stats, batch, train):
            imgs, labels = batch
            # Run model. During training, we need to update the BatchNorm statistics.
            outs = self.model.apply({'params': params, 'batch_stats': batch_stats},
                                    imgs,
                                    train=train,
                                    mutable=['batch_stats'] if train else False)
            logits, new_model_state = outs if train else (outs, None)
            loss = optax.softmax_cross_entropy_with_integer_labels(logits, labels).mean()
            acc = (logits.argmax(axis=-1) == labels).mean()
            return loss, (acc, new_model_state)
        # Training function
        def train_step(state, batch):
            loss_fn = lambda params: calculate_loss(params, state.batch_stats, batch, train=True)
            # Get loss, gradients for loss, and other outputs of loss function
            ret, grads = jax.value_and_grad(loss_fn, has_aux=True)(state.params)
            loss, acc, new_model_state = ret[0], *ret[1]
            # Update parameters and batch statistics
            state = state.apply_gradients(grads=grads, batch_stats=new_model_state['batch_stats'])
            return state, loss, acc
        # Eval function
        def eval_step(state, batch):
            # Return the accuracy for a single batch
            _, (acc, _) = calculate_loss(state.params, state.batch_stats, batch, train=False)
            return acc
        # jit for efficiency
        self.train_step = jax.jit(train_step)
        self.eval_step = jax.jit(eval_step)

    def init_model(self, exmp_imgs):
        # Initialize model
        init_rng = jax.random.PRNGKey(self.seed)
        variables = self.model.init(init_rng, exmp_imgs, train=True)
        self.init_params, self.init_batch_stats = variables['params'], variables['batch_stats']
        self.state = None

    def init_optimizer(self, num_epochs, num_steps_per_epoch):
        # Initialize learning rate schedule and optimizer
        if self.optimizer_name.lower() == 'adam':
            opt_class = optax.adam
        elif self.optimizer_name.lower() == 'adamw':
            opt_class = optax.adamw
        elif self.optimizer_name.lower() == 'sgd':
            opt_class = optax.sgd
        else:
            assert False, f'Unknown optimizer "{opt_class}"'
        # We decrease the learning rate by a factor of 0.1 after 60% and 85% of the training
        lr_schedule = optax.piecewise_constant_schedule(
            init_value=self.optimizer_hparams.pop('lr'),
            boundaries_and_scales=
                {int(num_steps_per_epoch*num_epochs*0.6): 0.1,
                 int(num_steps_per_epoch*num_epochs*0.85): 0.1}
        )
        # Clip gradients at max value, and evt. apply weight decay
        transf = [optax.clip(1.0)]
        if opt_class == optax.sgd and 'weight_decay' in self.optimizer_hparams:  # wd is integrated in adamw
            transf.append(optax.add_decayed_weights(self.optimizer_hparams.pop('weight_decay')))
        optimizer = optax.chain(
            *transf,
            opt_class(lr_schedule, **self.optimizer_hparams)
        )
        # Initialize training state
        self.state = TrainState.create(apply_fn=self.model.apply,
                                       params=self.init_params if self.state is None else self.state.params,
                                       batch_stats=self.init_batch_stats if self.state is None else self.state.batch_stats,
                                       tx=optimizer)

    def train_model(self, train_loader, val_loader, num_epochs=200):
        # Train model for defined number of epochs
        # We first need to create optimizer and the scheduler for the given number of epochs
        self.init_optimizer(num_epochs, len(train_loader))
        # Track best eval accuracy
        best_eval = 0.0
        for epoch_idx in tqdm(range(1, num_epochs+1)):
            self.train_epoch(train_loader, epoch=epoch_idx)
            if epoch_idx % 2 == 0:
                eval_acc = self.eval_model(val_loader)
                self.logger.add_scalar('val/acc', eval_acc, global_step=epoch_idx)
                if eval_acc >= best_eval:
                    best_eval = eval_acc
                    self.save_model(step=epoch_idx)
                self.logger.flush()

    def train_epoch(self, train_loader, epoch):
        # Train model for one epoch, and log avg loss and accuracy
        metrics = defaultdict(list)
        for batch in tqdm(train_loader, desc='Training', leave=False):
            self.state, loss, acc = self.train_step(self.state, batch)
            metrics['loss'].append(loss)
            metrics['acc'].append(acc)
        for key in metrics:
            avg_val = np.stack(jax.device_get(metrics[key])).mean()
            self.logger.add_scalar('train/'+key, avg_val, global_step=epoch)

    def eval_model(self, data_loader):
        # Test model on all images of a data loader and return avg loss
        correct_class, count = 0, 0
        for batch in data_loader:
            acc = self.eval_step(self.state, batch)
            correct_class += acc * batch[0].shape[0]
            count += batch[0].shape[0]
        eval_acc = (correct_class / count).item()
        return eval_acc

    def save_model(self, step=0):
        # Save current model at certain training iteration
        checkpoints.save_checkpoint(ckpt_dir=self.log_dir,
                                    target={'params': self.state.params,
                                            'batch_stats': self.state.batch_stats},
                                    step=step,
                                   overwrite=True)

    def load_model(self, pretrained=False):
        # Load model. We use different checkpoint for pretrained models
        if not pretrained:
            state_dict = checkpoints.restore_checkpoint(ckpt_dir=self.log_dir, target=None)
        else:
            state_dict = checkpoints.restore_checkpoint(ckpt_dir=os.path.join(CHECKPOINT_PATH, f'{self.model_name}.ckpt'), target=None)
        self.state = TrainState.create(apply_fn=self.model.apply,
                                       params=state_dict['params'],
                                       batch_stats=state_dict['batch_stats'],
                                       tx=self.state.tx if self.state else optax.sgd(0.1)   # Default optimizer
                                      )

    def checkpoint_exists(self):
        # Check whether a pretrained model exist for this autoencoder
        return os.path.isfile(os.path.join(CHECKPOINT_PATH, f'{self.model_name}.ckpt'))

def train_classifier(*args, num_epochs=200, **kwargs):
    # Create a trainer module with specified hyperparameters
    trainer = TrainerModule(*args, **kwargs)
    if not trainer.checkpoint_exists():  # Skip training if pretrained model exists
        trainer.train_model(train_loader, val_loader, num_epochs=num_epochs)
        trainer.load_model()
    else:
        trainer.load_model(pretrained=True)
    # Test trained model
    val_acc = trainer.eval_model(val_loader)
    test_acc = trainer.eval_model(test_loader)
    return trainer, {'val': val_acc, 'test': test_acc}

"""### Resnet

- Supports stable gradient propagation through the network

![image.png](data:image/png;base64,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)

On the left we have original resnet block where activation is applied after skip connection, whereas on right we have pre-activation resnet block. The latter is shown to perform better for very deep networks since the identity matrix(gradient of the residual connection) isnt harmed by any non-linear activation applied to it
"""

# Conv initialized with kaiming int, but uses fan-out instead of fan-in mode
# Fan-out focuses on the gradient distribution, and is commonly used in ResNets
resnet_kernel_init = nn.initializers.variance_scaling(2.0, mode='fan_out', distribution='normal')

class ResNetBlock(nn.Module):
    act_fn : callable  # Activation function
    c_out : int   # Output feature size
    subsample : bool = False  # If True, we apply a stride inside F

    @nn.compact
    def __call__(self, x, train=True):
        # Network representing F
        z = nn.Conv(self.c_out, kernel_size=(3, 3),
                    strides=(1, 1) if not self.subsample else (2, 2),
                    kernel_init=resnet_kernel_init,
                    use_bias=False)(x)
        z = nn.BatchNorm()(z, use_running_average=not train)
        z = self.act_fn(z)
        z = nn.Conv(self.c_out, kernel_size=(3, 3),
                    kernel_init=resnet_kernel_init,
                    use_bias=False)(z)
        z = nn.BatchNorm()(z, use_running_average=not train)

        if self.subsample:
            x = nn.Conv(self.c_out, kernel_size=(1, 1), strides=(2, 2), kernel_init=resnet_kernel_init)(x)

        x_out = self.act_fn(z + x)
        return x_out

"""* If subsample = True we shrink spatial dimensions by a factor of 2"""

class PreActResNetBlock(ResNetBlock):
    @nn.compact
    def __call__(self, x, train=True):
        # Network representing F
        z = nn.BatchNorm()(x, use_running_average=not train)
        z = self.act_fn(z)
        z = nn.Conv(self.c_out, kernel_size=(3, 3),
                    strides=(1, 1) if not self.subsample else (2, 2),
                    kernel_init=resnet_kernel_init,
                    use_bias=False)(z)
        z = nn.BatchNorm()(z, use_running_average=not train)
        z = self.act_fn(z)
        z = nn.Conv(self.c_out, kernel_size=(3, 3),
                    kernel_init=resnet_kernel_init,
                    use_bias=False)(z)

        if self.subsample:
            x = nn.BatchNorm()(x, use_running_average=not train)
            x = self.act_fn(x)
            x = nn.Conv(self.c_out,
                        kernel_size=(1, 1),
                        strides=(2, 2),
                        kernel_init=resnet_kernel_init,
                        use_bias=False)(x)

        x_out = z + x
        return x_out

"""![image.png](data:image/png;base64,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)

The orange blocks denote ResNet blocks with downsampling

### The Resnet Block
"""

class ResNet(nn.Module):
    num_classes : int
    act_fn : callable
    block_class : nn.Module # Flexible to use ResNetBlock or PreActResNetBlock
    num_blocks : tuple = (3, 3, 3)
    c_hidden : tuple = (16, 32, 64)

    @nn.compact
    def __call__(self, x, train=True):
        # A first convolution on the original image to scale up the channel size
        x = nn.Conv(self.c_hidden[0], kernel_size=(3, 3), kernel_init=resnet_kernel_init, use_bias=False)(x)
        if self.block_class == ResNetBlock:  # If pre-activation block, we do not apply non-linearities yet
            x = nn.BatchNorm()(x, use_running_average=not train)
            x = self.act_fn(x)

        # Creating the ResNet blocks
        for block_idx, block_count in enumerate(self.num_blocks):
            for bc in range(block_count):
                # Subsample the first block of each group, except the very first one.
                subsample = (bc == 0 and block_idx > 0)
                # ResNet block
                x = self.block_class(c_out=self.c_hidden[block_idx],
                                     act_fn=self.act_fn,
                                     subsample=subsample)(x, train=train)

        # Mapping to classification output
        x = x.mean(axis=(1, 2))
        x = nn.Dense(self.num_classes)(x)
        return x

"""In a surprising twist, we use SGD with momentum rather than Adam as the optimizer since it is empirically found to yield better results."""

resnet_trainer, resnet_results = train_classifier(model_name="ResNet",
                            model_class=ResNet,
                            model_hparams={"num_classes": 10,
                            "c_hidden": (16, 32, 64),
                            "num_blocks": (3, 3, 3),
                            "act_fn": nn.relu,
                            "block_class": ResNetBlock},
                              optimizer_name="SGD",
                              optimizer_hparams={"lr": 0.1,
                                                  "momentum": 0.9,
                                                  "weight_decay": 1e-4},
                              exmp_imgs=jax.device_put(
                                  next(iter(train_loader))[0]),
                              num_epochs=200)

"""Comparing the pre-activation block for comparison"""

preactresnet_trainer, preactresnet_results = train_classifier      (model_name="PreActResNet",
                      model_class=ResNet,
                      model_hparams={"num_classes": 10,
                                      "c_hidden": (16, 32, 64),
                                      "num_blocks": (3, 3, 3),
                                      "act_fn": nn.relu,
                                      "block_class": PreActResNetBlock},
                      optimizer_name="SGD",
                      optimizer_hparams={"lr": 0.1,
                                          "momentum": 0.9,
                                          "weight_decay": 1e-4},
                      exmp_imgs=jax.device_put(
                          next(iter(train_loader))[0]),
                      num_epochs=200)

